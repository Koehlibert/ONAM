featureName <- "Development"
ale$set.feature(featureName)
pdp$set.feature(featureName)
ice$set.feature(featureName)
AlePlot <- ale$plot()
rugData <- ggplot_build(AlePlot)$data[[2]]
PdpPlot <- pdp$plot()
IcePlot <- ice$plot()
AlePlot$scales$scales
AlePlot$layers
AlePlot$labels
AlePlot
rugData
PdpPlot
pdp$results
test <- pdp$results
View(test)
ale$results$.value <- ale$results$.value %>% scale(scale = FALSE)
pdp$results$.value <- pdp$results$.value %>% scale(scale = FALSE)
ale$results$.value <- ale$results$.value %>% scale(scale = FALSE)
ale$set.feature(featureName)
ale$results$.value <- ale$results$.value %>% scale(scale = FALSE)
pdp$set.feature(featureName)
pdp$results$.value <- pdp$results$.value %>% scale(scale = FALSE)
ice$set.feature(featureName)
ice$results$.value <- ice$results$.value %>% scale(scale = FALSE)
AlePlot <- ale$plot()
rugData <- ggplot_build(AlePlot)$data[[2]]
PdpPlot <- pdp$plot()
IcePlot <- ice$plot()
PHOPlot <- plotEffectGenericPost(BIBIEvalData, featureName) +
xlab(featureName) + ylab("Main Effect") +
geom_rug(sides = "b", alpha = rugData$alpha, linetype = rugData$linetype,
linewidth = rugData$linewidth)
# PHOPlotPre <- plotEffectGenericPre(BIBIEvalData, featureName)
combinedPlot <- ggarrange(AlePlot, PdpPlot, IcePlot, PHOPlot,
ncol = 2, nrow = 2)
combinedPlot
mean(AlePlot$data$.value)
mean(PdpPlot$data$.value)
View(partial_results_elevation_Development)
plot(ale$results$Development, pdp$results$Development)
length(ale$results$Development)
length(pdp$results$Development)
View(pdp$results)
length(PdpPlot$data$Development)
test <- ggplot_build(PdpPlot)
View(test)
ale$results$.value
mean(ale$results$.value)
AlePlot
PdpPlot
featureName <- "AreaSqKm"
pdp$set.feature(featureName)
allFeatures
featureName <- "AreaSqKM"
pdp$set.feature(featureName)
PdpPlot <- pdp$plot()
PdpPlot
pdp$results$.value <- pdp$results$.value %>% scale(scale = FALSE)
PdpPlot <- pdp$plot()
PdpPlot
PdpPlot
ice$set.feature(featureName)
ice$results$.value <- ice$results$.value %>% scale(scale = FALSE)
ale$set.feature(featureName)
ale$results$.value <- ale$results$.value %>% scale(scale = FALSE)
pdp$set.feature(featureName)
pdp$results$.value <- pdp$results$.value %>% scale(scale = FALSE)
ice$set.feature(featureName)
ice$results$.value <- ice$results$.value %>% scale(scale = FALSE)
AlePlot <- ale$plot()
rugData <- ggplot_build(AlePlot)$data[[2]]
PdpPlot <- pdp$plot()
IcePlot <- ice$plot()
PHOPlot <- plotEffectGenericPost(BIBIEvalData, featureName) +
xlab(featureName) + ylab("Main Effect") +
geom_rug(sides = "b", alpha = rugData$alpha, linetype = rugData$linetype,
linewidth = rugData$linewidth)
# PHOPlotPre <- plotEffectGenericPre(BIBIEvalData, featureName)
combinedPlot <- ggarrange(AlePlot, PdpPlot, IcePlot, PHOPlot,
ncol = 2, nrow = 2)
combinedPlot
library(iml)
library(ranger)
library(pdp)
library(ggpubr)
setwd("//imbie-fs/Projekte/Biostatistik/Projekte_Koehler/Deepregression/Keras Stacked Orthogonalization LA/")
source("FunctionsOrthoTest//KerasFunctionsSource.R")
BIBIEvalData <- readRDS("BIBIEvalData.RDS")
load(file = "rangerRF_BIBI.RData")
load(file = "BIBItrainData.RData")
BIBIPred <- rangerRF_BIBI$predictions
model <- Predictor$new(rangerRF_BIBI, data = train, y = BIBIPred)
imp <- FeatureImp$new(model, loss = "mae")
ale <- FeatureEffect$new(model, feature = "Forest", method = "ale")
pdp <- FeatureEffect$new(model, feature = "Forest", method = "pdp")
ice <- FeatureEffect$new(model, feature = "Forest", method = "ice")
allFeatures <- colnames(train)[-1]
for(featureName in allFeatures)
{
if((typeof(train[[featureName]]) != "double") |
!featureName %in% names(BIBIEvalData$totalFeaturePredsPost))
{
next
}
ale$set.feature(featureName)
ale$results$.value <- ale$results$.value %>% scale(scale = FALSE)
pdp$set.feature(featureName)
pdp$results$.value <- pdp$results$.value %>% scale(scale = FALSE)
ice$set.feature(featureName)
ice$results$.value <- ice$results$.value %>% scale(scale = FALSE)
AlePlot <- ale$plot()
rugData <- ggplot_build(AlePlot)$data[[2]]
PdpPlot <- pdp$plot()
IcePlot <- ice$plot()
PHOPlot <- plotEffectGenericPost(BIBIEvalData, featureName) +
xlab(featureName) + ylab("Main Effect") +
geom_rug(sides = "b", alpha = rugData$alpha, linetype = rugData$linetype,
linewidth = rugData$linewidth)
# PHOPlotPre <- plotEffectGenericPre(BIBIEvalData, featureName)
combinedPlot <- ggarrange(AlePlot, PdpPlot, IcePlot, PHOPlot,
ncol = 2, nrow = 2)
ggsave(paste(featureName, "_ICE_Combined.pdf", sep = ""), combinedPlot,
device = "pdf",
width = 8, height = 6)
PHOPlotSub <- plotSingleModels(BIBIEvalData, featureName) +
xlab(featureName) + ylab("Main Effect") +
theme(legend.position = "none") +
geom_rug(data = rugData, sides = "b", aes(x = x),
alpha = rugData$alpha, linetype = rugData$linetype, color = "black",
linewidth = rugData$linewidth)
# PHOPlotPre <- plotEffectGenericPre(BIBIEvalData, featureName)
ggsave(paste(featureName, "_SubModels.pdf", sep = ""), PHOPlotSub,
device = "pdf",
width = 8, height = 6)
}
partial_results_elevation_Agriculture <-
pdp::partial(rangerRF_BIBI, pred.var = c("elevation", "Agriculture"))
partial_results_elevation_Agriculture$yhat <-
partial_results_elevation_Agriculture$yhat %>% scale(scale = FALSE)
elevAgriPlot <- plotPartial(partial_results_elevation_Agriculture)
elevAgriPlotPHO <-
plotInteractionEffectGenericPost(BIBIEvalData,
"Agriculture", "elevation") +
coord_flip() + ylab("elevation") + xlab("Agriculture")
combinedPlot <- ggarrange(elevAgriPlot, elevAgriPlotPHO,
ncol = 2)
ggsave("elevAgriPlot.pdf", combinedPlot,
device = "pdf",
width = 11, height = 6)
partial_results_elevation_Development <-
pdp::partial(rangerRF_BIBI, pred.var = c("elevation", "Development"))
partial_results_elevation_Development$yhat <-
partial_results_elevation_Development$yhat %>% scale(scale = FALSE)
elevDevelPlot <- plotPartial(partial_results_elevation_Development)
elevDevelPlotPHO <-
plotInteractionEffectGenericPost(BIBIEvalData,
"Development", "elevation") +
coord_flip() + ylab("elevation") + xlab("Development")
combinedPlot <- ggarrange(elevDevelPlot, elevDevelPlotPHO,
ncol = 2)
ggsave("elevDevelPlot.pdf", combinedPlot,
device = "pdf",
width = 11, height = 6)
partial_results_Development_Agriculture <-
pdp::partial(rangerRF_BIBI, pred.var = c("Development", "Agriculture"))
partial_results_Development_Agriculture$yhat <-
partial_results_Development_Agriculture$yhat %>% scale(scale = FALSE)
DevelAgriPlot <- plotPartial(partial_results_Development_Agriculture)
DevelAgriPlotPHO <-
plotInteractionEffectGenericPost(BIBIEvalData,
"Agriculture", "Development") +
coord_flip() + ylab("Development") + xlab("Agriculture")
combinedPlot <- ggarrange(DevelAgriPlot, DevelAgriPlotPHO,
ncol = 2)
ggsave("DevelAgriPlot.pdf", combinedPlot,
device = "pdf",
width = 11, height = 6)
partial_results_LongLat <-
pdp::partial(rangerRF_BIBI, pred.var = c("Longitude", "Latitude"))
partial_results_LongLat$yhat <-
partial_results_LongLat$yhat %>% scale(scale = FALSE)
LongLatPlot <- plotPartial(partial_results_LongLat)
LongLatPlotPHO <-
plotInteractionEffectGenericPost(BIBIEvalData,
"Longitude", "Latitude") +
ylab("Latitude") + xlab("Longitude")
combinedPlot <- ggarrange(LongLatPlot, LongLatPlotPHO,
ncol = 2)
ggsave("LongLatPlot.pdf", combinedPlot,
device = "pdf",
width = 11, height = 6)
allPreds <- matrix(BIBIEvalData$totalFeaturePredsPost %>% unlist(),
ncol = length(BIBIEvalData$totalFeaturePredsPost))
totalVar2 <- abs(var(rowSums(allPreds)))
varDecomp <- var(allPreds)
totalVar <- sum(abs(varDecomp))
ResVar <- abs(varDecomp[1,1])
InterVar <- sum(abs(varDecomp[2:5, 2:5]))
mainVar <- sum(abs(varDecomp[6:24, 6:24]))
getwd()
rm(list = ls())
library(iml)
library(ranger)
library(pdp)
library(ggpubr)
setwd("//imbie-fs/Projekte/Biostatistik/Projekte_Koehler/Deepregression/Keras Stacked Orthogonalization LA/")
source("FunctionsOrthoTest//KerasFunctionsSource.R")
BIBIEvalData <- readRDS("BIBIEvalData.RDS")
load(file = "rangerRF_BIBI.RData")
load(file = "BIBItrainData.RData")
BIBIPred <- rangerRF_BIBI$predictions
originalData <- BIBIEvalData$data
n <- nrow(originalData)
.rs.restartR()
oldRes <- BIBIEvalData$totalFeaturePredsPre
warnings()
setwd("//imbie-fs/Projekte/Biostatistik/Projekte_Koehler/Deepregression/Keras Stacked Orthogonalization LA/")
setwd("//imbie-fs/Projekte/Biostatistik/Projekte_Koehler/Deepregression/ONAM/")
source("FunctionsOrthoTest//KerasFunctionsSource.R")
modelEvalData <- BIBIEvalData
colnames(modelEvalData$totalPredictions)
names(modelEvalData$totalPredictions)
View(modelEvalData)
.rs.restartR()
originalData <- modelEvalData$data
n <- nrow(originalData)
View(modelEvalData)
predictionData <- modelEvalData$predictionsData
predictionsData <- modelEvalData$predictionsData
rm(predictionData)
View(predictionsData)
length(unique(predictionsData$Effect))
predictionsData <- modelEvalData$predictionsData %>%
filter(PHO == "After")
length(unique(predictionsData$Effect))
#Initial Setup####
rm(list = ls())
gc()
#Initial Setup####
rm(list = ls())
gc()
# setwd("//imbie-fs/Projekte/Biostatistik/Projekte_Koehler/Deepregression/Keras Stacked Orthogonalization LA//")
# setwd("Z:/Biostatistik/Projekte_Koehler/Deepregression/Keras Stacked Orthogonalization LA//")
source("FunctionsOrthoTest//KerasFunctionsSource.R")
set.seed(1)
#Hyperparameters####
nSim <- 10
p <- 10
p_inf <- 3
n_inter <- factorial(p_inf)/(2*factorial(p_inf - 2))
AllNet <- TRUE
noisy <- TRUE
regularize <- TRUE
nVals <- c(2000,5000,10000)
Effects <- c(1,2,3)
noiseVals <- c(0.1,0.5,1)
simSetting <- expand.grid(nVals, Effects, noiseVals)
#DGP####
betasToSample <- seq(-3, 3, by = 0.5)[-7]
lotf <- list(function(x) cos(2*x),
function(x) tanh(3*x),
function(x) -x^3,
function(x) cos(x*3-2)*(-x*3),
function(x) ifelse(x > 0, pweibull(x, shape = 3),
pweibull(-x, shape = 0.5)),
function(x) x^2,
function(x) sin(x)*cos(x),
function(x) sqrt(abs(x)),
function(x) dnorm(x)-0.125,
function(x) -x * tanh(3*x) * sin(4*x))
interf <- list(function(x1, x2) x1 * (-x2),
function(x1, x2) sin(0.1*x1) * exp(x2),
function(x1, x2) max(x1, x2),
function(x1, x2) x1 - x2,
function(x1, x2) ifelse(x1 > 0, sqrt(abs(x2)), x2),
function(x1, x2) sqrt(x1^2 + x2^2),
function(x1, x2) cos(x1) * x2^3,
function(x1, x2) exp(0.5*x1) + sqrt(abs(x2-1)),
function(x1, x2) sqrt((x1 - 2)^2 + (x2 + 1) ^2)
)
#Run Simulation####
# for(iSetting in 1:nrow(simSetting))
for(iSetting in 21:nrow(simSetting))
{
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
for(j in 1:nSim)
{
progressPercent <- ((iSetting - 1)*nSim + j)/
(nrow(simSetting) * nSim)*100
# progressPercent <- ((iSetting - 1)*nSim + j)/
# (3 * nSim)*100
cat('\r',paste0(progressPercent, "% complete"))
flush.console()
#create data####
X <- matrix(runif(p * n, -3, 3), ncol = p)
originalData <- X
#purify effects to get only nonlinear part#####
interFPre <- lapply(1:n_inter, function(i)
{
purifyInterFunction(i, interf = interf,
interFIdx = interFIdx, X = X)
})
nonLinFPre <- lapply(1:p_inf, function(i)
{
purifyNonLinFunction(i, lotf = lotf, nonLinFIdx = nonLinFIdx,
X = X)
})
PHOList <- stackedOrthFunction(nonLinFPre, interFPre, 0.1,
originalData)
nonLinF <- PHOList$nonLinF
interF <- PHOList$interF
# trueBetas <- betas + PHOList$b
#Generate data####
Y <- rep(0, n)
# Y <- X %*% trueBetas
for(idx in 1:p_inf)
{
Y <- Y + nonLinF[[idx]]
}
for(idx in 1:n_inter)
{
Y <- Y + interF[[idx]]
}
if(noisy)
{
noise <- rnorm(n, sd = noisesd)
Y <- Y + noise
}
originalData <- cbind(originalData, Y)
colnames(originalData) <- c(paste("X", 1:p, sep = ""), "Y")
modelFormula <-
formula(Y ~ deep_model1(X1) + deep_model1(X2) + deep_model1(X3) +
deep_model1(X1, X2) + deep_model1(X1, X3) + deep_model1(X2, X3) +
deep_model1(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10))
list_of_deep_models = list(deep_model1 = getSubModel)
modelRunTime <-
system.time({modelRes <- fitPHOModel(modelFormula, list_of_deep_models,
originalData, 10)})
modelEvalData <- evaluateModel(modelRes, nonLinF,
simSetting[iSetting,],
modelRunTime)
resFileName <- paste("./UniformFeatureResults/", SettingString, "_run_", j, ".RDS", sep = "")
saveRDS(modelEvalData, file = resFileName)
}
}
j
for(iSetting in 21:nrow(simSetting))
{
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
for(j in 1:nSim)
{
if(iSetting == 21 & j < 3)
{
break
}
progressPercent <- ((iSetting - 1)*nSim + j)/
(nrow(simSetting) * nSim)*100
# progressPercent <- ((iSetting - 1)*nSim + j)/
# (3 * nSim)*100
cat('\r',paste0(progressPercent, "% complete"))
flush.console()
#create data####
X <- matrix(runif(p * n, -3, 3), ncol = p)
originalData <- X
#purify effects to get only nonlinear part#####
interFPre <- lapply(1:n_inter, function(i)
{
purifyInterFunction(i, interf = interf,
interFIdx = interFIdx, X = X)
})
nonLinFPre <- lapply(1:p_inf, function(i)
{
purifyNonLinFunction(i, lotf = lotf, nonLinFIdx = nonLinFIdx,
X = X)
})
PHOList <- stackedOrthFunction(nonLinFPre, interFPre, 0.1,
originalData)
nonLinF <- PHOList$nonLinF
interF <- PHOList$interF
# trueBetas <- betas + PHOList$b
#Generate data####
Y <- rep(0, n)
# Y <- X %*% trueBetas
for(idx in 1:p_inf)
{
Y <- Y + nonLinF[[idx]]
}
for(idx in 1:n_inter)
{
Y <- Y + interF[[idx]]
}
if(noisy)
{
noise <- rnorm(n, sd = noisesd)
Y <- Y + noise
}
originalData <- cbind(originalData, Y)
colnames(originalData) <- c(paste("X", 1:p, sep = ""), "Y")
modelFormula <-
formula(Y ~ deep_model1(X1) + deep_model1(X2) + deep_model1(X3) +
deep_model1(X1, X2) + deep_model1(X1, X3) + deep_model1(X2, X3) +
deep_model1(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10))
list_of_deep_models = list(deep_model1 = getSubModel)
modelRunTime <-
system.time({modelRes <- fitPHOModel(modelFormula, list_of_deep_models,
originalData, 10)})
modelEvalData <- evaluateModel(modelRes, nonLinF,
simSetting[iSetting,],
modelRunTime)
resFileName <- paste("./UniformFeatureResults/", SettingString, "_run_", j, ".RDS", sep = "")
saveRDS(modelEvalData, file = resFileName)
}
}
j
iSetting
for(iSetting in 26:nrow(simSetting))
{
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
for(j in 1:nSim)
{
if(iSetting == 26 & j < 6)
{
break
}
progressPercent <- ((iSetting - 1)*nSim + j)/
(nrow(simSetting) * nSim)*100
# progressPercent <- ((iSetting - 1)*nSim + j)/
# (3 * nSim)*100
cat('\r',paste0(progressPercent, "% complete"))
flush.console()
#create data####
X <- matrix(runif(p * n, -3, 3), ncol = p)
originalData <- X
#purify effects to get only nonlinear part#####
interFPre <- lapply(1:n_inter, function(i)
{
purifyInterFunction(i, interf = interf,
interFIdx = interFIdx, X = X)
})
nonLinFPre <- lapply(1:p_inf, function(i)
{
purifyNonLinFunction(i, lotf = lotf, nonLinFIdx = nonLinFIdx,
X = X)
})
PHOList <- stackedOrthFunction(nonLinFPre, interFPre, 0.1,
originalData)
nonLinF <- PHOList$nonLinF
interF <- PHOList$interF
# trueBetas <- betas + PHOList$b
#Generate data####
Y <- rep(0, n)
# Y <- X %*% trueBetas
for(idx in 1:p_inf)
{
Y <- Y + nonLinF[[idx]]
}
for(idx in 1:n_inter)
{
Y <- Y + interF[[idx]]
}
if(noisy)
{
noise <- rnorm(n, sd = noisesd)
Y <- Y + noise
}
originalData <- cbind(originalData, Y)
colnames(originalData) <- c(paste("X", 1:p, sep = ""), "Y")
modelFormula <-
formula(Y ~ deep_model1(X1) + deep_model1(X2) + deep_model1(X3) +
deep_model1(X1, X2) + deep_model1(X1, X3) + deep_model1(X2, X3) +
deep_model1(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10))
list_of_deep_models = list(deep_model1 = getSubModel)
modelRunTime <-
system.time({modelRes <- fitPHOModel(modelFormula, list_of_deep_models,
originalData, 10)})
modelEvalData <- evaluateModel(modelRes, nonLinF,
simSetting[iSetting,],
modelRunTime)
resFileName <- paste("./UniformFeatureResults/", SettingString, "_run_", j, ".RDS", sep = "")
saveRDS(modelEvalData, file = resFileName)
}
}
12*6
12*7
13*7
14*7
12*7
12*5
(10:19)*7
