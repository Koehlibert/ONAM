function(x) -x^3,
function(x) cos(x*3-2)*(-x*3),
function(x) ifelse(x > 0, pweibull(x, shape = 3),
pweibull(-x, shape = 0.5)),
function(x) x^2,
function(x) sin(x)*cos(x),
function(x) sqrt(abs(x)),
function(x) dnorm(x)-0.125,
function(x) -x * tanh(3*x) * sin(4*x))
interf <- list(function(x1, x2) x1 * (-x2),
function(x1, x2) sin(0.1*x1) * exp(x2),
function(x1, x2) max(x1, x2),
function(x1, x2) x1 - x2,
function(x1, x2) ifelse(x1 > 0, sqrt(abs(x2)), x2),
function(x1, x2) sqrt(x1^2 + x2^2),
function(x1, x2) cos(x1) * x2^3,
function(x1, x2) exp(0.5*x1) + sqrt(abs(x2-1)),
function(x1, x2) sqrt((x1 - 2)^2 + (x2 + 1) ^2))
#Run Simulation####
# for(iSetting in 1:nrow(simSetting))
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
iSetting <- 1
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
#create data####
X <- matrix(runif(p * n, -3, 3), ncol = p)
originalData <- X
#purify effects to get only nonlinear part#####
interFPre <- lapply(1:n_inter, function(i)
{
ONAM:::purifyInterFunction(i, interf = interf,
interFIdx = interFIdx, X = X)
})
nonLinFPre <- lapply(1:p_inf, function(i)
{
ONAM:::purifyNonLinFunction(i, lotf = lotf, nonLinFIdx = nonLinFIdx,
X = X)
})
PHOList <-
ONAM:::stackedOrthFunction(nonLinFPre, interFPre, 0.1,
originalData)
nonLinF <- PHOList$nonLinF
interF <- PHOList$interF
# trueBetas <- betas + PHOList$b
#Generate data####
Y <- rep(0, n)
# Y <- X %*% trueBetas
for(idx in 1:p_inf)
{
Y <- Y + nonLinF[[idx]]
}
for(idx in 1:n_inter)
{
Y <- Y + interF[[idx]]
}
if(noisy)
{
noise <- rnorm(n, sd = noisesd)
Y <- Y + noise
}
originalData <- cbind(originalData, Y)
colnames(originalData) <- c(paste("X", 1:p, sep = ""), "Y")
modelFormula <-
formula(Y ~ deep_model1(X1) + deep_model1(X2) + deep_model1(X3) +
deep_model1(X1, X2) + deep_model1(X1, X3) + deep_model1(X2, X3) +
deep_model1(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10))
list_of_deep_models = list(deep_model1 = ONAM:::getSubModel)
nEnsemble = 20
modelInfoList <-
ONAM:::getThetaFromFormula(modelFormula, list_of_deep_models)
data <- originalData
fitData <-
ONAM:::prepareData(data, modelInfoList)
Y <- data[,which(colnames(data) == as.character(modelInfoList$outcome))]
PHOEnsemble <- list()
modelObject <-
ONAM:::createModel(modelInfoList, list_of_deep_models)
wholeModel <- modelObject$model
modelList <- modelObject$modelList
#Fit model####
callback <-
keras::keras$callbacks$EarlyStopping(monitor = "loss",
patience = 10)
history <- wholeModel %>%
keras::fit(fitData, Y, epochs = 500, callbacks = callback,
verbose = 0)
library(dplyr)
history <- wholeModel %>%
keras::fit(fitData, Y, epochs = 500, callbacks = callback,
verbose = 0)
#Orthogonalize####
PHOEnsemble[[i]] <-
ONAM:::PHO(modelList, modelInfoList, fitData)
i <- 1
#Orthogonalize####
PHOEnsemble[[i]] <-
ONAM:::PHO(modelList, modelInfoList, fitData)
seq_along(1)
seq_along(5)
seq_along(3:5)
test <- PHOEnsemble[[1]]
U <- ONAM:::getU(test$modelList,modelIdxList = ONAM:::getModelIdxList(modelInfoList), modelInfoList, fitData)
residualEffect <- U %*% test$W_List[[1]]
U_Object <- ONAM:::getU(test$modelList,modelIdxList = ONAM:::getModelIdxList(modelInfoList), modelInfoList, fitData)
U <- U_Object$U
residualEffect <- U %*% test$W_List[[1]]
interEffect12 <- U %*% test$W_List[[2]]
interEffect13 <- U %*% test$W_List[[3]]
interEffect23 <- U %*% test$W_List[[4]]
mainEffect3 <- U %*% test$W_List[[5]]
mainEffect2 <- U %*% test$W_List[[6]]
mainEffect1 <- U %*% test$W_List[[7]]
plot(data[,3], mainEffect3)
plot(data[,2], mainEffect2)
plot(data[,1], mainEffect1)
SumInter <- interEffect12 + interEffect13 + interEffect23
SumMain <- mainEffect1 + mainEffect2 + mainEffect3
SumInterMain <- SumInter + SumMain
residualEffect %*% SumInterMain
t(residualEffect) %*% SumInterMain
t(SumInter) %*% SumMain
modelEvalData <- readRDS("UniformFeatureResults/n_10000_Eff_1_2_3_sd_0.1_run_1.RDS")
resF <- modelEvalData
resF <- modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
interF12 <- modelEvalData$totalFeaturePredsPost$X1_X2
interF13 <- modelEvalData$totalFeaturePredsPost$X1_X3
interF23 <- modelEvalData$totalFeaturePredsPost$X2_X3
mainF1 <- modelEvalData$totalFeaturePredsPost$X1
mainF2 <- modelEvalData$totalFeaturePredsPost$X2
mainF3 <- modelEvalData$totalFeaturePredsPost$X3
sumMain <- mainF1 + mainF2 + mainF3
sumInter <- interF12 + interF13 + interF23
sumInterMain <- sumMain + sumInter
t(resF) %*% sumInterMain
modelEvalData <-
readRDS("UniformFeatureResults/n_10000_Eff_1_2_3_sd_0.1_run_1.RDS")
mainF1Post <- modelEvalData$totalFeaturePredsPost$X1
mainF2Post <- modelEvalData$totalFeaturePredsPost$X2
mainF3Post <- modelEvalData$totalFeaturePredsPost$X3
mainF1Post <- modelEvalData$totalFeaturePredsPost$X1
mainF2Post <- modelEvalData$totalFeaturePredsPost$X2
mainF3Post <- modelEvalData$totalFeaturePredsPost$X3
resFPost <-
modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
modelEvalData <-
readRDS("UniformFeatureResults/n_10000_Eff_1_2_3_sd_0.1_run_1.RDS")
mainF1Pre <- modelEvalData$totalFeaturePredsPre$X1
mainF2Pre <- modelEvalData$totalFeaturePredsPre$X2
mainF3Pre <- modelEvalData$totalFeaturePredsPre$X3
mainF1Pre <- modelEvalData$totalFeaturePredsPre$X1
mainF2Pre <- modelEvalData$totalFeaturePredsPre$X2
mainF3Pre <- modelEvalData$totalFeaturePredsPre$X3
resFPre <-
modelEvalData$totalFeaturePredsPre$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
mainF1Post <- modelEvalData$totalFeaturePredsPost$X1
mainF2Post <- modelEvalData$totalFeaturePredsPost$X2
mainF3Post <- modelEvalData$totalFeaturePredsPost$X3
mainF1Post <- modelEvalData$totalFeaturePredsPost$X1
mainF2Post <- modelEvalData$totalFeaturePredsPost$X2
mainF3Post <- modelEvalData$totalFeaturePredsPost$X3
resFPost <-
modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPre <- mainF1Pre + mainF2Pre + mainF3Pre
mainF1Pre <- modelEvalData$totalFeaturePredsPre$X1
mainF2Pre <- modelEvalData$totalFeaturePredsPre$X2
mainF3Pre <- modelEvalData$totalFeaturePredsPre$X3
interF12Pre <- modelEvalData$totalFeaturePredsPost$X1_X2
interF13Pre <- modelEvalData$totalFeaturePredsPost$X1_X3
interF23Pre <- modelEvalData$totalFeaturePredsPost$X2_X3
resFPre <-
modelEvalData$totalFeaturePredsPre$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPre <- mainF1Pre + mainF2Pre + mainF3Pre
SumInterPre <- interF12Pre + interF13Pre + interF23Pre
sumInterMainPre <- sumMainPre + SumInterPre
t(resFPre) %*% sumInterMainPre
sumMainPre <- mainF1Pre + mainF2Pre + mainF3Pre
sumInterPre <- interF12Pre + interF13Pre + interF23Pre
sumInterMainPre <- sumMainPre + sumInterPre
t(sumInterPre) %*% sumMainPre
rm(list = ls())
modelEvalData <-
readRDS("UniformFeatureResults/n_10000_Eff_1_2_3_sd_0.1_run_1.RDS")
mainF1Pre <- modelEvalData$totalFeaturePredsPre$X1
mainF2Pre <- modelEvalData$totalFeaturePredsPre$X2
mainF3Pre <- modelEvalData$totalFeaturePredsPre$X3
interF12Pre <- modelEvalData$totalFeaturePredsPost$X1_X2
interF13Pre <- modelEvalData$totalFeaturePredsPost$X1_X3
interF23Pre <- modelEvalData$totalFeaturePredsPost$X2_X3
resFPre <-
modelEvalData$totalFeaturePredsPre$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPre <- mainF1Pre + mainF2Pre + mainF3Pre
sumInterPre <- interF12Pre + interF13Pre + interF23Pre
sumInterMainPre <- sumMainPre + sumInterPre
t(resFPre) %*% sumInterMainPre
t(sumInterPre) %*% sumMainPre
mainF1Post <- modelEvalData$totalFeaturePredsPost$X1
mainF2Post <- modelEvalData$totalFeaturePredsPost$X2
mainF3Post <- modelEvalData$totalFeaturePredsPost$X3
interF12Post <- modelEvalData$totalFeaturePostdsPost$X1_X2
interF13Post <- modelEvalData$totalFeaturePostdsPost$X1_X3
interF23Post <- modelEvalData$totalFeaturePostdsPost$X2_X3
resFPost <-
modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPost <- mainF1Post + mainF2Post + mainF3Post
sumInterPost <- interF12Post + interF13Post + interF23Post
sumInterMainPost <- sumMainPost + sumInterPost
t(resFPost) %*% sumInterMainPost
t(resFPre) %*% sumInterMainPre
t(sumInterPre) %*% sumMainPre
t(resFPost) %*% sumInterMainPost
t(sumInterPost) %*% sumMainPost
dim(sumInterMainPost)
length(sumInterMainPost)
resFPost <-
modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
resFPost
sumMainPost
sumInterPost
interF23Post
interF13Post
interF12Post
interF12Post <- modelEvalData$totalFeaturePredsPost$X1_X2
interF13Post <- modelEvalData$totalFeaturePredsPost$X1_X3
interF23Post <- modelEvalData$totalFeaturePredsPost$X2_X3
resFPost <-
modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPost <- mainF1Post + mainF2Post + mainF3Post
sumInterPost <- interF12Post + interF13Post + interF23Post
sumInterMainPost <- sumMainPost + sumInterPost
t(resFPost) %*% sumInterMainPost
t(sumInterPost) %*% sumMainPost
t(sumInterPre) %*% sumMainPre
plot(modelEvalData$data[,1], mainF1Post)
plot(modelEvalData$data[,1], mainF1Pre)
plot(modelEvalData$data[,1], mainF1Post)
plot(modelEvalData$data[,2], mainF2Pre)
plot(modelEvalData$data[,2], mainF2Post)
plot(modelEvalData$data[,3], mainF3Post)
plot(modelEvalData$data[,3], mainF3Pre)
plot(modelEvalData$data[,3], mainF3Post)
rm(list = ls())
modelEvalData <-
readRDS("UniformFeatureResults/n_10000_Eff_1_2_3_sd_0.1_run_1.RDS")
mainF1Pre <- modelEvalData$totalFeaturePredsPre$X1
mainF2Pre <- modelEvalData$totalFeaturePredsPre$X2
mainF3Pre <- modelEvalData$totalFeaturePredsPre$X3
interF12Pre <- modelEvalData$totalFeaturePredsPost$X1_X2
interF12Pre <- modelEvalData$totalFeaturePredsPre$X1_X2
interF13Pre <- modelEvalData$totalFeaturePredsPre$X1_X3
interF23Pre <- modelEvalData$totalFeaturePredsPre$X2_X3
resFPre <-
modelEvalData$totalFeaturePredsPre$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPre <- mainF1Pre + mainF2Pre + mainF3Pre
sumInterPre <- interF12Pre + interF13Pre + interF23Pre
sumInterMainPre <- sumMainPre + sumInterPre
t(resFPre) %*% sumInterMainPre
t(sumInterPre) %*% sumMainPre
mainF1Post <- modelEvalData$totalFeaturePredsPost$X1
mainF2Post <- modelEvalData$totalFeaturePredsPost$X2
mainF3Post <- modelEvalData$totalFeaturePredsPost$X3
interF12Post <- modelEvalData$totalFeaturePredsPost$X1_X2
interF13Post <- modelEvalData$totalFeaturePredsPost$X1_X3
interF23Post <- modelEvalData$totalFeaturePredsPost$X2_X3
resFPost <-
modelEvalData$totalFeaturePredsPost$X1_X2_X3_X4_X5_X6_X7_X8_X9_X10
sumMainPost <- mainF1Post + mainF2Post + mainF3Post
sumInterPost <- interF12Post + interF13Post + interF23Post
sumInterMainPost <- sumMainPost + sumInterPost
t(resFPost) %*% sumInterMainPost
t(sumInterPost) %*% sumMainPost
t(resFPre) %*% sumInterMainPre
t(sumInterPre) %*% sumMainPre
(t(resFPre) %*% sumInterMainPre) / (t(resFPost) %*% sumInterMainPost)
(t(resFPost) %*% sumInterMainPost) / (t(resFPre) %*% sumInterMainPre)
#Initial Setup####
rm(list = ls())
gc()
set.seed(1)
#Hyperparameters####
nSim <- 10
p <- 10
p_inf <- 3
n_inter <- factorial(p_inf)/(2*factorial(p_inf - 2))
AllNet <- TRUE
noisy <- TRUE
regularize <- TRUE
nVals <- c(2000,5000,10000)
Effects <- c(1,2,3)
noiseVals <- c(0.1,0.5,1)
simSetting <- expand.grid(nVals, Effects, noiseVals)
#DGP####
betasToSample <- seq(-3, 3, by = 0.5)[-7]
lotf <- list(function(x) cos(2*x),
function(x) tanh(3*x),
function(x) -x^3,
function(x) cos(x*3-2)*(-x*3),
function(x) ifelse(x > 0, pweibull(x, shape = 3),
pweibull(-x, shape = 0.5)),
function(x) x^2,
function(x) sin(x)*cos(x),
function(x) sqrt(abs(x)),
function(x) dnorm(x)-0.125,
function(x) -x * tanh(3*x) * sin(4*x))
interf <- list(function(x1, x2) x1 * (-x2),
function(x1, x2) sin(0.1*x1) * exp(x2),
function(x1, x2) max(x1, x2),
function(x1, x2) x1 - x2,
function(x1, x2) ifelse(x1 > 0, sqrt(abs(x2)), x2),
function(x1, x2) sqrt(x1^2 + x2^2),
function(x1, x2) cos(x1) * x2^3,
function(x1, x2) exp(0.5*x1) + sqrt(abs(x2-1)),
function(x1, x2) sqrt((x1 - 2)^2 + (x2 + 1) ^2))
#Run Simulation####
# for(iSetting in 1:nrow(simSetting))
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
iSettings <- 1
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
iSetting <- 1
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
for(j in 1:nSim)
{
if(iSetting == 26 & j < 6)
{
break
}
progressPercent <- ((iSetting - 1)*nSim + j)/
(nrow(simSetting) * nSim)*100
# progressPercent <- ((iSetting - 1)*nSim + j)/
# (3 * nSim)*100
cat('\r',paste0(progressPercent, "% complete"))
flush.console()
#create data####
X <- matrix(runif(p * n, -3, 3), ncol = p)
originalData <- X
#purify effects to get only nonlinear part#####
interFPre <- lapply(1:n_inter, function(i)
{
ONAM:::purifyInterFunction(i, interf = interf,
interFIdx = interFIdx, X = X)
})
nonLinFPre <- lapply(1:p_inf, function(i)
{
ONAM:::purifyNonLinFunction(i, lotf = lotf, nonLinFIdx = nonLinFIdx,
X = X)
})
PHOList <-
ONAM:::stackedOrthFunction(nonLinFPre, interFPre, 0.1,
originalData)
nonLinF <- PHOList$nonLinF
interF <- PHOList$interF
# trueBetas <- betas + PHOList$b
#Generate data####
Y <- rep(0, n)
# Y <- X %*% trueBetas
for(idx in 1:p_inf)
{
Y <- Y + nonLinF[[idx]]
}
for(idx in 1:n_inter)
{
Y <- Y + interF[[idx]]
}
if(noisy)
{
noise <- rnorm(n, sd = noisesd)
Y <- Y + noise
}
originalData <- cbind(originalData, Y)
colnames(originalData) <- c(paste("X", 1:p, sep = ""), "Y")
modelFormula <-
formula(Y ~ deep_model1(X1) + deep_model1(X2) + deep_model1(X3) +
deep_model1(X1, X2) + deep_model1(X1, X3) + deep_model1(X2, X3) +
deep_model1(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10))
list_of_deep_models = list(deep_model1 = ONAM:::getSubModel)
modelRunTime <-
system.time({modelRes <-
ONAM:::fitPHOModel(modelFormula, list_of_deep_models,
originalData, 10)})
modelEvalData <-
ONAM:::evaluateModel(modelRes, nonLinF,
simSetting[iSetting,],
modelRunTime)
resFileName <- paste("./UniformFeatureResults/", SettingString, "_run_", j, ".RDS", sep = "")
saveRDS(modelEvalData, file = resFileName)
}
#Initial Setup####
rm(list = ls())
gc()
set.seed(1)
#Hyperparameters####
nSim <- 10
p <- 10
p_inf <- 3
n_inter <- factorial(p_inf)/(2*factorial(p_inf - 2))
AllNet <- TRUE
noisy <- TRUE
regularize <- TRUE
nVals <- c(2000,5000,10000)
Effects <- c(1,2,3)
noiseVals <- c(0.1,0.5,1)
simSetting <- expand.grid(nVals, Effects, noiseVals)
#DGP####
betasToSample <- seq(-3, 3, by = 0.5)[-7]
lotf <- list(function(x) cos(2*x),
function(x) tanh(3*x),
function(x) -x^3,
function(x) cos(x*3-2)*(-x*3),
function(x) ifelse(x > 0, pweibull(x, shape = 3),
pweibull(-x, shape = 0.5)),
function(x) x^2,
function(x) sin(x)*cos(x),
function(x) sqrt(abs(x)),
function(x) dnorm(x)-0.125,
function(x) -x * tanh(3*x) * sin(4*x))
interf <- list(function(x1, x2) x1 * (-x2),
function(x1, x2) sin(0.1*x1) * exp(x2),
function(x1, x2) max(x1, x2),
function(x1, x2) x1 - x2,
function(x1, x2) ifelse(x1 > 0, sqrt(abs(x2)), x2),
function(x1, x2) sqrt(x1^2 + x2^2),
function(x1, x2) cos(x1) * x2^3,
function(x1, x2) exp(0.5*x1) + sqrt(abs(x2-1)),
function(x1, x2) sqrt((x1 - 2)^2 + (x2 + 1) ^2))
#Run Simulation####
# for(iSetting in 1:nrow(simSetting))
iSetting <- 1
#Simulation setting####
n <- simSetting[iSetting, 1]
nonLinFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
interFIdx <- 3 * (simSetting[iSetting, 2] - 1) + 1:3
noisesd <- simSetting[iSetting, 3]
SettingString <- paste("n_", n, "_Eff_",
paste(nonLinFIdx, collapse = "_"),
"_sd_", noisesd, sep = "")
#create data####
X <- matrix(runif(p * n, -3, 3), ncol = p)
originalData <- X
#purify effects to get only nonlinear part#####
interFPre <- lapply(1:n_inter, function(i)
{
ONAM:::purifyInterFunction(i, interf = interf,
interFIdx = interFIdx, X = X)
})
nonLinFPre <- lapply(1:p_inf, function(i)
{
ONAM:::purifyNonLinFunction(i, lotf = lotf, nonLinFIdx = nonLinFIdx,
X = X)
})
PHOList <-
ONAM:::stackedOrthFunction(nonLinFPre, interFPre, 0.1,
originalData)
nonLinF <- PHOList$nonLinF
interF <- PHOList$interF
# trueBetas <- betas + PHOList$b
#Generate data####
Y <- rep(0, n)
# Y <- X %*% trueBetas
for(idx in 1:p_inf)
{
Y <- Y + nonLinF[[idx]]
}
for(idx in 1:n_inter)
{
Y <- Y + interF[[idx]]
}
if(noisy)
{
noise <- rnorm(n, sd = noisesd)
Y <- Y + noise
}
originalData <- cbind(originalData, Y)
colnames(originalData) <- c(paste("X", 1:p, sep = ""), "Y")
modelFormula <-
formula(Y ~ deep_model1(X1) + deep_model1(X2) + deep_model1(X3) +
deep_model1(X1, X2) + deep_model1(X1, X3) + deep_model1(X2, X3) +
deep_model1(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10))
list_of_deep_models = list(deep_model1 = ONAM:::getSubModel)
data <- originalData
modelInfoList <-
ONAM:::getThetaFromFormula(modelFormula, list_of_deep_models)
fitData <-
ONAM:::prepareData(data, modelInfoList)
Y <- data[,which(colnames(data) == as.character(modelInfoList$outcome))]
PHOEnsemble <- list()
